// * ************************************************************
// * * START:                                         kernel.cs *
// * ************************************************************

// * ************************************************************
// *                      INFORMATIONS
// * ************************************************************
// * Kernel for the library. (Ex. Memory management)
// * kernel.cs
// * 
// * --
// *
// * Feel free to use this class in your projects, but don't
// * remove the header to keep the paternity of the class.
// * 
// * ************************************************************
// *                      CREDITS
// * ************************************************************
// * Originally created by CptSky (December 7th, 2011)
// * Copyright (C) 2011 CptSky
// *
// * ************************************************************

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace ItemCreator.CoreDLL
{
    public unsafe class Kernel
    {
        #region Constants

        /// <summary>
        /// Standard size for a buffer. (4 KiB)
        /// 4 KiB represent the size of one disc block on most file system.
        /// /!\ Do not change the value to avoid I/O error. /!\
        /// </summary>
        public const int MAX_BUFFER_SIZE = 4096;

        /// <summary>
        /// This macro expands to an integral constant expression whose value is the maximum value returned by
        /// the rand function.
        /// This value is library dependent, but is granted to be at least 32767.
        /// </summary>
        public const int RAND_MAX = 0x7FFF;

        #endregion //Constants

        #region Variables

        private static uint Seed = 1;

        #endregion //Variables

        #region Methods

        /// <summary>
        /// The pseudo-random number generator is initialized using the argument passed as seed.
        /// For every different seed value used in a call to srand, the pseudo-random number generator can
        /// be expected to generate a different succession of results in the subsequent calls to rand.
        /// Two different initializations with the same seed, instructs the pseudo-random generator to generate
        /// the same succession of results for the subsequent calls to rand in both cases.
        /// If seed is set to 1, the generator is reinitialized to its initial value and produces the same values
        /// as before any call to rand or srand.
        /// </summary>
        public static void srand(uint seed)
        {
            Seed = seed;
        }

        /// <summary>
        /// Returns a pseudo-random integral number in the range 0 to RAND_MAX.
        /// This number is generated by an algorithm that returns a sequence of apparently non-related numbers
        /// each time it is called. This algorithm uses a seed to generate the series, which should be initialized
        /// to some distinctive value using srand.
        /// </summary>
        public static int rand() => (int)(((Seed = Seed * 0x343FD + 0x269EC3) >> 16) & RAND_MAX);

        /// <summary>
        /// Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.
        /// The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.
        /// </summary>
        public static void* malloc(int size)
        {
            var ptr = Marshal.AllocHGlobal(size).ToPointer();
            return ptr;
        }

        /// <summary>
        /// Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes
        /// all its bits to zero. The effective result is the allocation of an zero-initialized memory block of
        /// size bytes.
        /// </summary>
        public static void* calloc(int size)
        {
            var ptr = Marshal.AllocHGlobal(size).ToPointer();

            //This method is less effecient than the memset call, but is more portable.
            //The use of Int32 on both x86 and x64 is the best solution to upgrade the speed.
            //It may be due to the aligment of the data.

            //We consider that under Windows, any integer with all its bits to zero is equal to zero.
            //So we set the integer to zero. It is not the real implementation, but an optimized one
            //for any OS running the .net/mono framework.

            var count = size / sizeof(int);
            for (var i = 0; i < count; i++)
                *((int*)ptr + i) = 0;

            var pos = size - size % sizeof(int);
            for (var i = 0; i < size % sizeof(int); i++)
                *((byte*)ptr + pos + i) = 0;

            return ptr;
        }

        /// <summary>
        /// The size of the memory block pointed to by the ptr parameter is changed to the size bytes, expanding or
        /// reducing the amount of memory available in the block.
        /// The function may move the memory block to a new location, in which case the new location is returned.
        /// The content of the memory block is preserved up to the lesser of the new and old sizes,
        /// even if the block is moved. If the new size is larger, the value of the newly allocated portion is
        /// indeterminate.
        /// In case that ptr is NULL, the function behaves exactly as malloc, assigning a new block of size bytes and
        /// returning a pointer to the beginning of it.
        /// In case that the size is 0, the memory previously allocated in ptr is deallocated as if a call to free
        /// was made, and a NULL pointer is returned.
        /// </summary>
        public static void* realloc(void* ptr, int size)
        {
            ptr = ptr != null ? Marshal.ReAllocHGlobal((IntPtr)ptr, new IntPtr(size)).ToPointer() : Marshal.AllocHGlobal(size).ToPointer();
            return ptr;
        }

        /// <summary>
        /// A block of memory previously allocated using a call to malloc, calloc or realloc is deallocated, making
        /// it available again for further allocations.
        /// The pointer is not set to NULL. It has to be set manually.
        /// </summary>
        public static void free(void* ptr)
        {
            if (ptr != null)
                Marshal.FreeHGlobal((IntPtr)ptr);
        }

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly numbytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(void* dest, void* src, int size)
        {
            //This method is less effecient than the Memcpy call, but it is more portable.
            //The use of Int32 on both x86 and x64 is the best solution to upgrade the speed.
            //It may be due to the aligment of the data.

            var count = size / sizeof(int);
            for (var i = 0; i < count; i++)
                *((int*)dest + i) = *((int*)src + i);

            var pos = size - size % sizeof(int);
            for (var i = 0; i < size % sizeof(int); i++)
                *((byte*)dest + pos + i) = *((byte*)src + pos + i);
        }

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly num bytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(byte[] dest, void* src, int size) => Marshal.Copy((IntPtr)src, dest, 0, size);

        /// <summary>
        /// Copies the values of num bytes from the location pointed by source directly to the memory block pointed
        /// by destination.
        /// The underlying type of the objects pointed by both the source and destination pointers are irrelevant for
        /// this function; The result is a binary copy of the data.
        /// The function does not check for any terminating null character in source - it always copies exactly num bytes.
        /// To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be
        /// at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).
        /// </summary>
        public static void memcpy(void* dest, byte[] src, int size) => Marshal.Copy(src, 0, (IntPtr)dest, size);

        /// <summary>
        /// Sets the first num bytes of the block of memory pointed by ptr to the specified value.
        /// </summary>
        public static void* memset(void* ptr, byte value, int num)
        {
            for (var i = 0; i < num; i++)
                *((byte*)ptr + i) = value;
            return ptr;
        }

        /// <summary>
        /// Returns the length of str.
        /// The length of a C string is determined by the terminating null-character: A C string is as long as
        /// the amount of characters between the beginning of the string and the terminating null character.
        /// This should not be confused with the size of the array that holds the string.
        /// </summary>
        public static int strlen(byte* ptr)
        {
            for (var i = 0; i < int.MaxValue; i++)
            {
                if (ptr[i] == '\0')
                    return i;
            }
            return int.MaxValue;
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static string cstring(byte* src, int size)
        {
            if (src == null)
                return null;

            var builder = new StringBuilder(size);
            for (var i = 0; i < size; i++)
            {
                if (src[i] == '\0')
                    break;

                builder.Append((char)src[i]);
            }
            return builder.ToString();
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static string cstring(byte[] src)
        {
            if (src == null)
                return null;

            var builder = new StringBuilder(src.Length);
            foreach (var t in src)
            {
                if (t == '\0')
                    break;
                builder.Append((char)t);
            }
            return builder.ToString();
        }

        /// <summary>
        /// Convert a Windows-1252 null-terminated string in an UNICODE managed string object.
        /// This method is a custom one. It may has bugs.
        /// </summary>
        public static string cstring(byte[] src, int pos, int size)
        {
            if (src == null)
                return null;

            var builder = new StringBuilder(size);
            for (var i = 0; i < size; i++)
            {
                if (src[i + pos] == '\0')
                    break;
                builder.Append((char)src[i + pos]);
            }
            return builder.ToString();
        }

        public static void assert(bool expression)
        {
            #if DEBUG
            if (!expression)
                throw new Exception("Assertion failed!");
            #endif
        }

        #endregion //Methods
    }
}

// * ************************************************************
// * * END:                                           kernel.cs *
// * ************************************************************